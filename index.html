<!DOCTYPE html>
<html lang="es">
<head>
    <!-- ... (el mismo head original) ... -->
</head>
<body>
<div class="container">
    <!-- ... (mismo HTML original) ... -->
</div>

<script>
// ... (funciones limpiarExpr y derivarFuncion se mantienen igual) ... 

function crearExplicacionLarga(funcion) {
    let pasos = "";
    const expr = cleanExpr(funcion);
    
    try {
        // Paso 1: Definición formal
        pasos += `Definición formal:\nf'(x) = limₕ→₀ [f(x+h) - f(x)] / h\n\n`;
        pasos += `Para f(x) = ${funcion}:\n`;
        pasos += `f'(x) = limₕ→₀ [${funcion.replace(/x/g, '(x+h)')} - ${funcion}] / h\n\n`;

        // Paso 2: Desarrollo algebraico
        const f_x = math.parse(expr);
        const f_xh = f_x.transform(node => {
            if (node.isSymbolNode && node.name === 'x') {
                return math.parse('(x + h)');
            }
            return node;
        });
        
        const numerador = math.simplify(math.subtract(f_xh, f_x));
        const exprConH = math.divide(numerador, math.parse('h'));
        const simplificado = math.simplify(exprConH);
        
        pasos += `Desarrollo:\n`;
        pasos += `= limₕ→₀ [${numerador.toString().replace(/\*\*/g, '^')}]/h\n`;
        pasos += `= limₕ→₀ ${simplificado.toString().replace(/\*\*/g, '^')}\n\n`;

        // Paso 3: Aplicar límite
        const limite = simplificado.evaluate({h: 0});
        pasos += `Aplicando el límite:\n`;
        pasos += `= ${math.simplify(limite).toString().replace(/\*\*/g, '^')}\n\n`;

        pasos += `Resultado final:\nf'(x) = ${limite.toString().replace(/\*\*/g, '^')}`;

    } catch (e) {
        pasos += "Error en el cálculo simbólico. Usando método alternativo...";
    }
    return pasos;
}

// ... (resto del código igual) ... 
</script>
</body>
</html>
